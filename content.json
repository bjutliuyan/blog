{"pages":[],"posts":[{"title":"(一)面向对象基础","text":"本文对面向对象基础进行一个简单回顾，方便之后理解各种有趣的设计模式，几分钟就可读完。 前言本人本科专业为软件工程，曾参加过一些算法方面竞赛，因为对研究方面较感兴趣，也是为了进一步扩展知识面，研究生阶段开始投入HCI方面研究，主要是针对视觉方面的人机交互人体目标检测进行研究。 在研究生刚开始阶段曾和实验室小伙伴协同开发过两个企业级WEB方面项目，预计今年九月份都能正式上线： ONOS系统（前端）[中国通号院CRSC]采用Vue框架 设备管理系统（全栈）[北京诚星科技有限]自己搭建环境，后台采用Spring+SpringMVC+Hibernate框架，前端采用EasyUI框架 当然，在这期间也曾遇到项目重构、Bug接连不断等各方面问题，在了解自己能力尚且不足同时，越来越明白设计模式、高内聚低耦合、程序规范化、质量检测等在项目开发中真正的重要性。无论做python开发还是以后做研究，工程类的项目，该思想应该都有值得借鉴之处。因此我准备在文章分类里多添加一个设计模式的分类，在这里对主要经典常用的一些设计模式进行相关介绍总结。相信整体浏览下来你一定能受益匪浅。 知识理解 类与实例化 类：具有相同属性和功能的对象的集合；那么为什么要用类和实例而不是传统的函数调用呢，这就相当于如果居委会的电视放在你家里，而别人家里没有，于是街坊邻里都要到你家来看电视（函数调用），这样并不合适。所以正确的办法应该是将公用的方法放在居委会（类文件）。 实例：类的具体对象；实例化相当于从类工厂又生产出一台电视，任何需要的地方都可以实例化它。 构造方法与方法重载 构造方法：对类进行初始化，比如对于一个猫的实例，我们希望一出生就可以有姓名，那么就应该写一个有参数的构造方法：12Cat cat1 = new Cat(&quot;喵喵&quot;)Cat cat2 = new Cat(&quot;咪咪&quot;) 方法重载：提供了创建同名的多个方法能力，可以在不改变原方法基础上，新增功能；重载也算是提供了方法的可扩展能力，比如实例化一个猫的时候给它起不起名字都可以：12Cat cat1 = new Cat()Cat cat2 = new Cat(&quot;喵喵&quot;) 属性与修饰符属性的getter setter作用是添加控制；修饰符常用的有public private 封装继承多态 封装：每个对象都包含它能进行操作所需要的所有信息 继承：（Java中构造方法不能被继承，继承使得修改和扩展都变得容易，但也增大了两个类之间的耦合性以及破坏包装，将父类暴露给子类） 多态：不同的对象可以执行相同动作，但要通过它们自己的实现代码来执行。比如说有一对父子是表演“京剧”的，有一天父亲发高烧上不了台表演，退票的话肯定会大大影响声誉，于是就决定让儿子代父亲上台表演。这里有几点需要注意：(一)子类以父类的身份出现；(二)子类在工作时以自己的方式来实现；(三)子类以父类身份出现时，子类特有属性和方法不可以使用123arrayAnimal = new Animal[2];arrayAnimal[0] = new Cat(&quot;小花&quot;);arrayAnimal[1] = new Dog(&quot;阿毛&quot;); 重构采用合适的设计模式对原先结构进行重新构建 抽象类与接口 抽象类：实例化没有任何意义不能实例化的类例如说一只猫长得什么样可以想象 ，说动物长什么样，没办法知道。抽象方法必须被子类重写，如果一个类中包含抽象方法也一定是抽象类；实际中看具体情况看父类是否需要改成抽象类。 接口：接口是将隐式公共方法和属性组合起来，以封装特定功能的集合。以下图为例，比如变出东西是小叮当、孙悟空、猪八戒分别具备的功能，如果为了更具有普遍意义而让它们的父类也具有此种功能，显然是不合适的，比如猫并不具备变出来东西功能。所以为了将特定行为进行抽样，采用接口。主要需要注意的是接口与抽象类的区别与联系： 抽象类 接口 对类的抽取 对行为的抽取 对一些相似类对象，用继承抽象类 若行为跨越不同类的对象可使用接口 抽象类是从子类中泛化出父类 接口是不知道子类的存在，预先定义 一个类只能继承一个抽象类 一个类可继承多个接口 集合与泛型 集合：用于对数据进行存储和检索的专用类叫做集合比如说ArrayList集合就是对IList接口的实现； 泛型是具有占位符（参数类型）的类、结构、接口、方法泛型集合可以将类型参数作为它所存储对对象类型的占位符。1List &lt;Animal&gt; arraylist;s 委托与事件","link":"/blog/2019/08/13/设计模式/001-面向对象基础/"},{"title":"(二)简单工厂模式","text":"面向对象的好处在于通过封装、继承、多态把程序的耦合度降低。使用设计模式可以使得程序更加的灵活，容易修改且易于复用。 简单工厂模式 例子：使用任何一种面向对象的语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。 首先使用面向对象的封装特将操作抽成一个类： Operation运算类： 客户端代码：在只使用封装的基础上，如果此时要添加一个求根号的操作，则需在Operation类的switch中新增一个分支，但是应该避免在新增分支的时候对原有代码进行修改。因此应该把加减乘除等运算分离，修改其中一个不影响另外几个，增加其它运算算法也不影响其它代码。 使用继承抽离操作类中的具体算法： 定义四个子类继承操作类：在该基础上可以实现，如果想要新增或修改一个算法，只需新增一个子类或修改一个子类，对其它方法不会产生影响。但是问题来了，不知道该如何让计算器去实例化对象，总不能在客户端代码里写一个switch判断，看是什么操作符返回什么运算子类进行操作吧。那么如果再新加一个运算子类（比如说开根号），总不能再去修改客户端代码，在switch里添加一个分支吧。 使用多态添加一个工厂类，实例化出合适的对象： 工厂类： 客户端代码： 类图：这样再新加一个操作，只需新增一个操作子类，然后再在工厂类里添加一个分支就行了。","link":"/blog/2019/08/16/设计模式/002-简单工厂模式/"},{"title":"web项目外网服务器","text":"本地JAVAWEB项目，如果想通过外网URL可以直接访问，就需要将本地程序包的war包上传到远程服务器指定文件。本文以上传ubuntu服务器为例介绍。 步骤 远程服务器配置安装Apache、Tomcat、MySQL[参考网址] 将本地程序上传服务器 将数据库脚本.sql文件上传服务器 将本地程序上传服务器在配置好服务器环境之后，选择任何一种可连接远程终端工具将项目文件上传即可，在这里推荐Mobatek，支持窗口可视化及shell等多种用户操作方式。 登录方式选择ssh，输入远程服务器ip地址、用户 将压缩后的程序war包放入/var/lib/tomcat/webapps文件夹下 此时连接 服务器ip:8080/项目名即可外网访问项目（服务器运行慢的情况下，刚将项目上传需要多刷新几遍才能出来） 将本地数据库上传服务器 将本地数据库导出到.sql脚本文件，再将该文件上传到服务器任意文件夹下 在命令行进入mysql命令模式 1234mysql -u用户名 -p密码 //进入数据库命令模式show databases; //查看当前有哪些数据库creat database 数据库名 //创建自己的数据库source /var/lib/tomcat/webapps/数据库名.sql //执行上传的sql脚本文件，source后拼接的是.sql文件的路径 额外需注意问题：windows数据库不区分大小写，Linux区分，需要修改解决办法是：修改MySQL的配置文件my.cnf，在[mysqld]部分添加如下配置选项lower_case_table_names = 1，然后重启MySQL服务即可","link":"/blog/2019/08/12/WEB/web项目发布外网服务器/"},{"title":"hexo个人博客搭建","text":"Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub上。以下步骤操作简单，只需先自行安装好node.js和git，剩余2~3小时大概就可完成。 所需工具 node.js git 安装配置步骤 安装node.js和git之后安装hexo:npm install -g hexo-cli安装完成之后使用npm -v查看是否安装成功 创建hexo项目在本地新建一个blog的文件夹在这个文件右键进入git bash模式命令模式下执行hexo init初始化博客 生成SSH密钥打开Git Bash，使用以下命令配置gitgit config --global user.name &quot;你的github用户的名字&quot;git config --global user.email &quot;你的github账户邮箱&quot;cd ~/.sshssh-keygen -t rsa -C &quot;你的github账户邮箱&quot;连续三个回车eval &quot;$(ssh-agent -s)&quot;，添加密钥到ssh-agentssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agentcat ~/.ssh/id_rsa.pub复制此时显示的内容，内容应该是以ssh-rsa开头 Github新建一个仓库，并配置SSH密钥Ctrl+C退出后，在GitHub上新建一个新的仓库，仓库名随意，不过需要记录下来，我这里起名叫blog，最下面的Initialize this repository with a README要勾选上，然后保存即可。进入这个仓库后选择Settings，在左侧选项卡Options中翻到下面，GItHub Pages这项，Source选择master branch，选择save后，会在这部分的标题处写明这个仓库的url，这就是你博客的url了。还是页面的左侧的选项卡，Deploy 选择Add deploy key，添加密钥。 Title随意，我设置为了blog Key粘贴我们刚才复制的那一段。 最下面Allow write access要打勾. 选择Add Key即可。 然后在Git Bash中使用 ssh -T git@github.com测试，如果看到Hi后面是你的用户名，就说明成功了。 使用npm install安装需要的组件 使用npm install hexo-deployer-git --save安装插件 修改hexo配置文件 打开本地博客的根目录，找到_config.yml文件，在文件的开头处，第二部分，url改成自己Github仓库的地址，root改为自己/自己本地仓库名/，如下所示： 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://github.com/bjutliuyan/blogroot: /blog/permalink: :year/:month/:day/:title/permalink_defaults: 再在最下面添加如下片段，repository这项，应该去GitHub里面新建的那个叫blog的仓库里面找。进入仓库主页后，点击右侧绿色的按钮Clone or download，在新弹出的窗口右上角选择Use SSH，然后将下面的文字复制粘贴到此处。修改完配置文件后保存退出即可。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:Davidham3/blog.git branch: master 生成博客hexo g 发布博客hexo d 本地预览博客hexo s通过localhost:4000可以本地预览 本地预览效果","link":"/blog/2019/08/04/随笔/hexo个人博客搭建/"},{"title":"(四)设计模式基本原则法则","text":"本节对4个基本原则及1个基本法则进行简要整理介绍。 拍摄UFO——单一职责原则 单一职责：就一个类而言，应该仅有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。 随着移动终端的发展，智能手机已经集成了众多功能：听音乐、玩游戏、拍照、摄像等。但有时一件产品简单一些，职责单一些，或许是更好的选择，比如摄像机拍摄性能要比手机更好一些。 比如要写一个WinForm窗口程序，总不能把操作的方法都写入窗口类，更好的策略应该是将界面代码和逻辑代码相分离，即将界面职责和逻辑职责单独分开。（手机的发展有它的特点，而编程时，我们却是要在类的职责分离上多思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样） 考研求职两不误——开闭原则 开闭原则：对于扩展是开放的，对于更改是封闭的。面对需求的改变应保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本。当然改变大都是不可预测的，设计人员需要先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。 比如在简单工厂运算器问题中，如果想添加一个乘法运算，只需要新增一个运算子类就行，与加法、减法、客户端隔离开来。这样就是面对需求，对程序的改动是通过增加新代码实现，而不是更改现有的代码。 （比如，考研过程中，考研本身是不会改变的，为了做完全准备，可以在考研期间不影响考研本身前提下，扩展的写一写简历了解招聘的资讯） 会修电脑不会修收音机——依赖倒转原则 依赖倒转原则： 高层模块不应依赖低层模块，两个都应依赖抽象 抽象不应依赖细节，细节应该依赖抽象 我们可以把电脑理解成大的软件系统，任何部件如CPU、内存、硬盘、显卡等都可以理解为程序中封装的类或程序集，不管哪一个出了问题都可以在不影响别的部件的前提下进行修改和替换。具体一点就是接口和抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其它受到影响。这使得高层模块和低层模块都能很好被复用。 收音机就是典型的耦合过度，只要收音机出问题，不懂的人根本没法修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难以维护。 不太理解的话在看下面一个例子：从上面的类图中可以看出，司机类和奔驰车类都属于细节，并没有实现或继承抽象，它们是对象级别的耦合。通过类图可以看出司机有一个drive()方法，用来开车，奔驰车有一个run()方法，用来表示车辆运行，并且奔驰车类依赖于司机类，用户模块表示高层模块，负责调用司机类和奔驰车类。 这样乍一看没问题，但是有一天如果司机想换一辆宝马了，但是却不能开，因为司机类里没有对宝马的依赖。下面引入依赖倒转原则重新设计一下类图：可以看出在新增低层模块（汽车）时，只修改了高层模块（Client），对已有的司机和车类都不用变动。 里氏代换原则 里氏代换原则：子类型必须能够替换掉父类型。 迪米特法则 迪米特法则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。 （类似于在controller层调用service层，再通过service层调用dao层访问数据库一样；而不是直接的由控制层调用数据访问层。）","link":"/blog/2019/09/03/设计模式/004-设计模式基本原则法则总结/"},{"title":"hexo主题配置+博客发布方法","text":"如果你已经成功搭建个人博客，可进一步更换不同主题及添加个性化设置，主题传送门：Themes ，我自己使用的是icarus 主题。 更换主题 克隆icarus主题到本地博客theme文件夹下： git clone https://github.com/ppoffice/hexo-theme-icarus.git 打开站点的_config.yml配置文件，修改主题为icarus: theme: hexo-theme-icarus发布文章文章编写采用Markdown标记语言书写。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。Markdown基本语法大概十几分钟即可学会，更有很多专门性编辑文本软件支持Markdown编写及同步预览。在此推荐Yu Writer Pro。 建立新发布文章命令行运行：hexo n &quot;博客名&quot; 采用Markdown编辑博客中需要用到的一些图片建议使用网络图片链接，减少加载时间 发布博客 12hexo ghexo d 个性化设置 鼠标点击、音乐等 添加评论功能：推荐使用gitment 添加动画[模型预览][添加方法] 添加访客统计：推荐使用revolvermaps [操作步骤]，添加到主题theme文件夹/layout/widget下对应的页面相应组件文件内","link":"/blog/2019/08/09/随笔/hexo主题配置+发布博客方法/"},{"title":"(三)商场促销——策略模式","text":"面向对象的编程并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的集合才是类。 需求： 假如设计一个商场收银软件，营业员根据客户所购买的商品的单价和数量，向客户收费。==考虑到不同商品有不同的促销方式：打1折、打3折、满300减100、满200减50、满100积分10点（积分达到一定程度可以领取相对应奖品）==。考虑界面如下： 简单工厂实现 按照上一节的讲法可以根据简单工厂模式建立类图如下，其中注意为了更好的抽象，应将打折操作（1折、2折等）抽象为一个类而不是两个类，其余操作也类似：如果现在需要再添加打5折、满500减200活动，按照简单工厂的思想，只需要在收费生成对象工厂添加两个switch条件，再在下拉选框里加两项就OK了；如果加入满100送10积分的活动，需要添加该收费标准子类，再到界面稍加改动， 可以看出的是，简单工厂只是解决了对象创建的问题，每次维护和扩展收费方式都要改动这个工厂，以致代码需要重新编译部署。面对算法时常变动，应该有更好的设计模式去选择。 策略模式实现 策略模式：是一种定义一系列算法的方法，从概念上看，所有这些算法完成的都是相同的工作，只是实现不同，它可以相同的方式调用所有的算法，减少各种算法与使用算法类之间的耦合。（即通过一个Context类，引入Strategy策略父类，根据传入不同对象，调用具体对应方法），**策略模式封装变化**CashContext类：客户端主要代码： 简单工厂-策略模式相结合 可以发现策略模式又回到未用简单工厂之前的老套路，直接在哭护短去判断使用哪一个算法。显然是不合适的。所以可以将简单工厂在策略模式基础上将判断过程从客户端程序移走。改造后CashContext类：改造后客户端主要代码：对比原先简单工厂的发现，简单工厂需要客户端认识两个类：CashSuper、CashFactory；而现在只需要认识一个CashContext类就可以了。使得具体的收费算法彻底地与客户端分离，连算法的父类CashSuper都不让客户端认识了，耦合度更加降低。不过，目前仍不够完美，因为CashContext里还是用到了switch判断，但是相比原先的简单工厂改动成本较小。当然还有更好的办法，比如反射技术，在后面会进行相关整理介绍。","link":"/blog/2019/08/23/设计模式/003-商场促销——策略模式/"},{"title":"pycharm进行远程服务器代码编写与调试","text":"PyCharm是一种Python IDE，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，用于支持Django框架下的专业Web开发。基于一些原因，平常我们经常需要将自己的项目上传到远程服务器，进行远程连接调试。 优点 可以直接在本机上编写代码 代码自动同步到远程服务器 在远程服务器上的解释器中执行代码，返回结果。和本地使用pycharm是一样的感觉。","link":"/blog/2019/09/05/python/pycharm进行远程服务器代码编写与调试/"}],"tags":[{"name":"设计模式","slug":"设计模式","link":"/blog/tags/设计模式/"},{"name":"WEB","slug":"WEB","link":"/blog/tags/WEB/"},{"name":"hexo搭建","slug":"hexo搭建","link":"/blog/tags/hexo搭建/"},{"name":"Markdown","slug":"Markdown","link":"/blog/tags/Markdown/"},{"name":"Pycharm","slug":"Pycharm","link":"/blog/tags/Pycharm/"}],"categories":[{"name":"设计模式","slug":"设计模式","link":"/blog/categories/设计模式/"},{"name":"WEB","slug":"WEB","link":"/blog/categories/WEB/"},{"name":"随笔","slug":"随笔","link":"/blog/categories/随笔/"},{"name":"Python","slug":"Python","link":"/blog/categories/Python/"}]}